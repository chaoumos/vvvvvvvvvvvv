
import {
  collection,
  addDoc,
  query,
  where,
  getDocs,
  orderBy,
  Timestamp,
  doc,
  updateDoc,
  deleteDoc,
  onSnapshot,
  type Unsubscribe,
  getDoc,
  setDoc,
} from 'firebase/firestore';
import type { Blog, BlogStatus, SelectedTheme, ApiConnection, BlogPost } from '../types';
import { Octokit } from '@octokit/rest'; 
import { db } from './client-config';
import {
    getGitHubAuthenticatedUserLogin,
    createGitHubRepo,
    commitFilesToRepo, 
    type GitHubRepoInfo, 
} from '../github'; 
import { generateHugoConfig, type GenerateHugoConfigInput } from '@/ai/flows/generate-hugo-config';

const BLOGS_COLLECTION = 'blogs';
const API_CONNECTIONS_COLLECTION = 'api_connections';
const POSTS_SUBCOLLECTION = 'posts';

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

async function getBlogPostsForBlog(blogId: string): Promise<BlogPost[]> {
  if (!db) {
    throw new Error("Firestore database is not initialized for fetching posts.");
  }
  const posts: BlogPost[] = [];
  try {
    const postsQuery = query(
      collection(db, BLOGS_COLLECTION, blogId, POSTS_SUBCOLLECTION),
      orderBy('createdAt', 'desc')
    );
    const querySnapshot = await getDocs(postsQuery);
    querySnapshot.forEach(docSnapshot => {
      const data = docSnapshot.data();
      const createdAtTimestamp = data.createdAt as Timestamp;
      posts.push({
        id: docSnapshot.id,
        ...data,
        createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
        description: data.description || `A post about ${data.title}`, 
      } as BlogPost);
    });
    return posts;
  } catch (error) {
    console.error(`Error fetching posts for blog ${blogId}:`, error);
    throw new Error('Failed to fetch blog posts.');
  }
}


export async function simulateBlogCreationProcess(blogId: string, siteNameFromArgs: string): Promise<void> {
  if (!db) {
    const firestoreErrorMsg = "Firestore not initialized during creation simulation.";
    console.error(firestoreErrorMsg);
    await updateBlogStatus(blogId, 'failed', { error: firestoreErrorMsg });
    return;
  }

  let blogData: Blog | undefined;
  let octokit: Octokit | undefined;
  let owner: string = '';
  let repoNameForGithub: string = ''; 
  let userId: string | undefined;
  let githubRepoUrl: string | undefined;
  let defaultBranch: string = 'main';

  try {
    const blogDocRef = doc(db, BLOGS_COLLECTION, blogId);
    const blogDocSnapshot = await getDoc(blogDocRef);

    if (!blogDocSnapshot.exists()) {
      throw new Error(`Blog with ID ${blogId} not found.`);
    }

    const rawData = blogDocSnapshot.data();
    userId = rawData?.userId;
    if (!userId) { throw new Error('User ID not found in blog document.'); }

    const createdAtTimestamp = rawData.createdAt as Timestamp;
    blogData = {
      id: blogDocSnapshot.id,
      ...rawData,
      createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (rawData.createdAt || 0),
    } as Blog;
    
    repoNameForGithub = blogData.siteName || siteNameFromArgs;
    if (!repoNameForGithub) {
        throw new Error('Site name for GitHub repository is missing.');
    }

    await updateBlogStatus(blogId, 'creating_repo');
    console.log(`Blog ${blogId}: Status updated to creating_repo.`);

    const apiConnections = await getApiConnection(userId);
    if (!apiConnections?.githubApiKey) {
      const errorMsg = 'GitHub API key is missing. Please add your GitHub Personal Access Token in the API Connections settings.';
      await updateBlogStatus(blogId, 'failed', { error: errorMsg });
      throw new Error(errorMsg);
    }

    octokit = new Octokit({ auth: apiConnections.githubApiKey });
    owner = await getGitHubAuthenticatedUserLogin(octokit);
    console.log(`Blog ${blogId}: Authenticated GitHub user: ${owner}`);

    const sanitizedDescription = (blogData.description || `A Hugo blog for ${repoNameForGithub} generated by HugoHost`)
      .replace(/[\u0000-\u001F\u007F-\u009F]/g, ' ')
      .replace(/\s\s+/g, ' ')
      .trim();

    console.log(`Blog ${blogId}: Attempting to get or create GitHub repo "${owner}/${repoNameForGithub}".`);
    const repoDetails: GitHubRepoInfo = await createGitHubRepo(octokit, owner, repoNameForGithub, sanitizedDescription);
    githubRepoUrl = repoDetails.html_url; 
    repoNameForGithub = repoDetails.name; 
    defaultBranch = repoDetails.default_branch;
    console.log(`Blog ${blogId}: GitHub repo ready: ${githubRepoUrl} (Default branch: ${defaultBranch})`);
    
    await updateBlogStatus(blogId, 'preparing_site_structure', { githubRepoUrl, deploymentNote: `GitHub repository ${githubRepoUrl} created. Preparing initial site structure...` });
    console.log(`Blog ${blogId}: Status updated to preparing_site_structure.`);

    const filesToCommit: Array<{ path: string; content: string }> = [];

    const readmeContent = `# ${blogData.blogTitle}\n\nThis Hugo site for "${blogData.blogTitle}" was generated by HugoHost.\nSite Name: ${blogData.siteName}\nTheme: ${blogData.theme.name} (${blogData.theme.gitUrl})\n\nTo run locally:\n1. Clone this repository.\n2. Ensure you have Hugo installed.\n3. If using Hugo Modules for the theme, run \`hugo mod init your.module/path\` then \`hugo mod get -u\` in the repo root.\n4. Run \`hugo server\`.\n`;
    filesToCommit.push({ path: 'README.md', content: readmeContent });
    
    let themeIdentifier = blogData.theme.id || blogData.theme.name.toLowerCase().replace(/[^a-z0-9_-]+/gi, '-');

    const aiPromptForConfig = `Generate a hugo.toml file for a blog titled "${blogData.blogTitle}".
The base URL should be "https://example.com". This is a placeholder and will be updated upon deployment.
The language code should be "en-us".
The theme should be "${themeIdentifier}". This is important.
Include a placeholder for Google Analytics.
Output only the raw TOML content. No explanations or markdown.
Example structure for theme:
theme = "${themeIdentifier}" 

[params]
  description = "${blogData.description.replace(/"/g, '\\"')}"
`;
    const hugoConfigInput: GenerateHugoConfigInput = {
      projectTitle: blogData.blogTitle,
      blogName: blogData.siteName,
      userPrompt: aiPromptForConfig,
    };
    console.log(`Blog ${blogId}: Generating hugo.toml with AI for theme: ${themeIdentifier}`);
    const aiResult = await generateHugoConfig(hugoConfigInput);
    let hugoConfigContent = aiResult.hugoConfig;

    if (!hugoConfigContent.includes(`theme =`) && !hugoConfigContent.includes(`theme =`)) {
      hugoConfigContent = `theme = "${themeIdentifier}"\n${hugoConfigContent}`;
      console.warn(`Blog ${blogId}: AI did not include theme line, adding it. Check hugo.toml.`);
    } else if (!hugoConfigContent.match(new RegExp(`theme\\s*=\\s*["']${themeIdentifier}["']`))) {
        hugoConfigContent = hugoConfigContent.replace(/theme\s*=\\s*["'].*["']/, `theme = "${themeIdentifier}"`);
         console.warn(`Blog ${blogId}: AI might have set a different theme, attempting to correct. Check hugo.toml. Current: ${hugoConfigContent.match(/theme\s*=\\s*["'].*["']/)?.[0]}`);
    }

    filesToCommit.push({ path: 'hugo.toml', content: hugoConfigContent });
    console.log(`Blog ${blogId}: hugo.toml generated.`);

    const welcomePost: BlogPost = {
      id: 'welcome-post', blogId, userId, 
      title: `Welcome to ${blogData.blogTitle}!`, 
      content: `This is your first post. Welcome to your new Hugo site, **${blogData.blogTitle}**!\n\nYou can start editing this file or add new posts in the \`content/posts/\` directory.\n\nHappy blogging!`,
      createdAt: Date.now(), status: 'published', description: "Your first post on this new blog."
    };
     const firstStepsPost: BlogPost = {
      id: 'first-steps-post', blogId, userId,
      title: "Getting Started with Your Hugo Blog",
      content: `Here are a few things you might want to do next:\n\n1.  **Customize your theme**: Look into the theme's documentation (\`${blogData.theme.name}\`). You might need to add it as a Hugo Module (\`hugo mod init your/module/path\` then \`hugo mod get -u ${blogData.theme.gitUrl}\` if it's a module-compatible theme, or clone it into the \`themes/\` directory).\n2.  **Update \`hugo.toml\`**: Fine-tune your site's configuration.\n3.  **Create more content**: Add new Markdown files to \`content/posts/\`.\n4.  **Explore Hugo features**: Check out [Hugo Documentation](https://gohugo.io/documentation/).\n\nEnjoy your new blog!`,
      createdAt: Date.now() + 86400000, status: 'published', description: "A few tips to get you started."
    };
    
    const postsToPushInitially = [welcomePost, firstStepsPost];
    postsToPushInitially.forEach(post => {
        const slug = (post.title || `post-${post.id}`).toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
        filesToCommit.push({ path: `content/posts/${slug}.md`, content: (global as any).formatPostToMarkdown ? (global as any).formatPostToMarkdown(post) : post.content }); 
    });


    const standardDirs = ['archetypes', 'data', 'layouts', 'static', 'content', 'themes'];
    standardDirs.forEach(dir => filesToCommit.push({ path: `${dir}/.gitkeep`, content: '' }));
    
    await updateBlogStatus(blogId, 'pushing_content_to_repo', { githubRepoUrl, deploymentNote: "Pushing initial site structure to GitHub..." });
    console.log(`Blog ${blogId}: Committing initial site structure (${filesToCommit.length} files) to ${owner}/${repoNameForGithub} on branch ${defaultBranch}.`);

    const commitResult = await commitFilesToRepo(
      octokit, owner, repoNameForGithub, defaultBranch, filesToCommit,
      "HugoHost: Initial site structure with config, README, and dummy content"
    );

    if (!commitResult || !commitResult.commitSha) {
      throw new Error("Failed to commit initial site files to GitHub.");
    }
    console.log(`Blog ${blogId}: Successfully committed initial site structure. Commit SHA: ${commitResult.commitSha}`);
    
    const existingPosts = await getBlogPostsForBlog(blogId);
    if (existingPosts.length > 0) {
        console.log(`Blog ${blogId}: Found ${existingPosts.length} existing posts in Firestore. Pushing them now.`);
        const postFiles = existingPosts.map(post => {
            const slug = (post.title || `post-${post.id}`).toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
            return { path: `content/posts/${slug}.md`, content: (global as any).formatPostToMarkdown ? (global as any).formatPostToMarkdown(post) : post.content };
        });
        await commitFilesToRepo(octokit, owner, repoNameForGithub, defaultBranch, postFiles, "HugoHost: Add existing blog posts from Firestore");
        console.log(`Blog ${blogId}: Pushed ${existingPosts.length} Firestore posts.`);
    }

    const finalDeploymentNote = `GitHub repository ${githubRepoUrl} is ready. You can now deploy to Cloudflare or another hosting provider.`;
    await updateBlogStatus(blogId, 'ready_for_deployment', {
      githubRepoUrl,
      deploymentNote: finalDeploymentNote,
      // liveUrl is removed here, will be set after actual deployment
    });
    console.log(`Blog ${blogId}: Status updated to ready_for_deployment. GitHub setup complete.`);

  } catch (error: any) {
    console.error(`Error in blog creation simulation for ${blogId}:`, error);
    let simulationErrorMessage = `GitHub setup failed: ${error.message || 'Unknown error'}`;

    if (error.name === 'HttpError' || error.status) { 
        const status = error.status || 'N/A';
        let ghMessage = error.message; 
        if (error.response?.data?.message) {
          ghMessage = error.response.data.message;
        }
        simulationErrorMessage = `GitHub API Error (${status}): ${ghMessage}.`;
        if (error.response?.data?.documentation_url) {
          simulationErrorMessage += ` Review: ${error.response.data.documentation_url}`;
        }
         if (error.response?.data?.errors) {
           simulationErrorMessage += ` Details: ${JSON.stringify(error.response.data.errors)}`;
        }
        console.error("GitHub API Error details for log:", error.response?.data || error);
    }
    
    if (simulationErrorMessage.length > 1000) {
      simulationErrorMessage = simulationErrorMessage.substring(0, 997) + "...";
    }
    try {
      const repoUrlForError = githubRepoUrl || (owner && repoNameForGithub ? `https://github.com/${owner}/${repoNameForGithub}` : undefined);
      await updateBlogStatus(blogId, 'failed', { error: simulationErrorMessage, githubRepoUrl: repoUrlForError });
      console.log(`Blog ${blogId}: Status updated to failed due to: ${simulationErrorMessage}`);
    } catch (statusUpdateError) {
      console.error(`Blog ${blogId}: Critical - Failed to update blog status to 'failed' after primary error:`, statusUpdateError);
    }
  }
}


export async function addBlog(userId: string, blogData: Omit<Blog, 'id' | 'userId' | 'createdAt' | 'status'>): Promise<string> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    const docRef = await addDoc(collection(db, BLOGS_COLLECTION), {
      ...blogData,
      userId,
      status: 'pending' as BlogStatus,
      createdAt: Timestamp.now(),
      name: blogData.blogTitle, 
    });
    return docRef.id;
  } catch (error) {
    console.error('Error adding blog:', error);
    throw new Error('Failed to add blog to Firestore.');
  }
}

export async function getUserBlogs(userId: string): Promise<Blog[]> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    const q = query(
      collection(db, BLOGS_COLLECTION),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc')
    );
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(docSnapshot => {
      const data = docSnapshot.data();
      const createdAtTimestamp = data.createdAt as Timestamp;
      return {
        id: docSnapshot.id,
        ...data,
        createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
      } as Blog;
    });
  } catch (error) {
    console.error('Error fetching user blogs:', error);
    throw new Error('Failed to fetch user blogs.');
  }
}

export function streamUserBlogs(
  userId: string,
  onUpdate: (blogs: Blog[]) => void,
  onError: (error: Error) => void
): Unsubscribe {
  if (!db) {
    const initError = new Error("Firestore database is not initialized. Cannot stream blogs.");
    console.error(initError.message);
    onError(initError);
    return () => {};
  }
  const q = query(
    collection(db, BLOGS_COLLECTION),
    where('userId', '==', userId),
    orderBy('createdAt', 'desc')
  );

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const blogs = querySnapshot.docs.map(docSnapshot => {
      const data = docSnapshot.data();
      const createdAtTimestamp = data.createdAt as Timestamp;
      return {
        id: docSnapshot.id,
        ...data,
        createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
      } as Blog;
    });
    onUpdate(blogs);
  }, (err: any) => {
    console.error("Error streaming user blogs from Firestore:", err);
    let errorMessage = err.message || 'An unknown error occurred while streaming blogs.';
    if (err.code === 'failed-precondition' && err.message.includes('query requires an index')) {
        errorMessage = `Firestore query requires an index. Please create it. The Firestore console should provide a link to create the missing index. Details: ${err.message}`;
    } else if (err.code === 'permission-denied') {
        errorMessage = `Permission denied. Check Firestore security rules. Details: ${err.message}`;
    } else if (err.code === 'unimplemented' && err.message.includes('currently building')) {
      errorMessage = `The required Firestore index is building. Please wait a few minutes and try again. Details: ${err.message}`;
    }
    onError(new Error(errorMessage));
  });

  return unsubscribe;
}

export async function getBlog(blogId: string, userId: string): Promise<Blog | null> {
  if (!db) {
    throw new Error("Firestore database is not initialized.");
  }
  if (!blogId || !userId) {
    console.error("getBlog called with missing blogId or userId.");
    throw new Error("Blog ID and User ID are required.");
  }
  try {
    const blogRef = doc(db, BLOGS_COLLECTION, blogId);
    const docSnapshot = await getDoc(blogRef);

    if (docSnapshot.exists()) {
      const data = docSnapshot.data();
      if (data.userId !== userId) {
        console.warn(`User ${userId} attempted to access blog ${blogId} owned by ${data.userId}.`);
        return null;
      }
      const createdAtTimestamp = data.createdAt as Timestamp;
      return {
        id: docSnapshot.id,
        ...data,
        createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
      } as Blog;
    }
    return null;
  } catch (error: any) {
    console.error(`Error fetching blog ${blogId}:`, error);
    throw new Error(`Failed to fetch blog details.`);
  }
}


export async function updateBlogStatus(blogId: string, status: BlogStatus, details?: Partial<Pick<Blog, 'githubRepoUrl' | 'liveUrl' | 'error' | 'deploymentNote' | 'cloudflarePagesProjectName' | 'cloudflareAccountId' >>): Promise<void> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    const blogRef = doc(db, BLOGS_COLLECTION, blogId);
    await updateDoc(blogRef, { status, ...details, updatedAt: Timestamp.now() });
  } catch (error) {
    console.error('Error updating blog status:', error);
    throw new Error('Failed to update blog status.');
  }
}

export async function deleteBlog(blogId: string): Promise<void> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    const blogRef = doc(db, BLOGS_COLLECTION, blogId);
    await deleteDoc(blogRef);
  } catch (error) {
    console.error('Error deleting blog:', error);
    throw new Error('Failed to delete blog.');
  }
}

export async function saveApiConnection(userId: string, data: Partial<Omit<ApiConnection, 'userId'>>): Promise<void> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    if (!userId) {
      throw new Error("User ID is missing.");
    }
    const apiConnectionRef = doc(db, API_CONNECTIONS_COLLECTION, userId);
    const dataToSave: Partial<ApiConnection> = { userId };
    (Object.keys(data) as Array<keyof Omit<ApiConnection, 'userId'>>).forEach(key => {
      if (data[key] !== undefined) {
        (dataToSave as any)[key] = data[key];
      }
    });
    await setDoc(apiConnectionRef, dataToSave, { merge: true });
  } catch (error: any) {
    console.error('Error saving API connection:', error);
    let toastMessage = "Failed to save API connections.";
    if (error.code === 'permission-denied') toastMessage += " Check Firestore rules.";
    else if (error.message) toastMessage += ` Details: ${error.message.substring(0,100)}`;
    throw new Error(toastMessage.substring(0, 250));
  }
}

export async function getApiConnection(userId: string): Promise<ApiConnection | null> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    if (!userId) {
      throw new Error("User ID is required.");
    }
    const apiConnectionRef = doc(db, API_CONNECTIONS_COLLECTION, userId);
    const docSnapshot = await getDoc(apiConnectionRef);

    if (docSnapshot.exists()) {
      const data = docSnapshot.data();
      return {
        userId: data.userId,
        githubApiKey: data.githubApiKey || undefined,
        cloudflareApiToken: data.cloudflareApiToken || undefined,
        cloudflareApiKey: data.cloudflareApiKey || undefined,
        cloudflareEmail: data.cloudflareEmail || undefined,
        cloudflareAccountId: data.cloudflareAccountId || undefined,
      } as ApiConnection;
    }
    return null;
  } catch (error) {
    console.error('Error fetching API connection:', error);
    throw new Error('Failed to fetch API connection.');
  }
}

export async function addBlogPost(
  userId: string,
  blogId: string,
  postData: Omit<BlogPost, 'id' | 'blogId' | 'userId' | 'createdAt' | 'updatedAt'>
): Promise<string> {
  if (!db) throw new Error("Firestore database is not initialized.");
  if (!userId || !blogId) throw new Error("User ID and Blog ID are required.");

  try {
    const blog = await getBlog(blogId, userId); 
    if (!blog) throw new Error("Blog not found or permission denied.");

    const postsCollectionRef = collection(db, BLOGS_COLLECTION, blogId, POSTS_SUBCOLLECTION);
    const docRef = await addDoc(postsCollectionRef, {
      ...postData,
      userId, 
      blogId, 
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    });
    return docRef.id;
  } catch (error) {
    console.error('Error adding blog post:', error);
    throw new Error('Failed to add blog post.');
  }
}

export function streamBlogPosts(
  userId: string, 
  blogId: string,
  onUpdate: (posts: BlogPost[]) => void,
  onError: (error: Error) => void
): Unsubscribe {
  if (!db) {
    onError(new Error("Firestore database is not initialized."));
    return () => {};
  }
  if (!userId || !blogId) {
    onError(new Error("User ID and Blog ID are required."));
    return () => {};
  }

  const postsCollectionRef = collection(db, BLOGS_COLLECTION, blogId, POSTS_SUBCOLLECTION);
  const q = query(postsCollectionRef, orderBy('createdAt', 'desc'));

  return onSnapshot(q, (querySnapshot) => {
    const posts = querySnapshot.docs.map(docSnapshot => {
      const data = docSnapshot.data();
      const createdAtTimestamp = data.createdAt as Timestamp;
      const updatedAtTimestamp = data.updatedAt as Timestamp;
      return {
        id: docSnapshot.id,
        blogId: blogId, 
        userId: data.userId, 
        ...data,
        createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
        updatedAt: updatedAtTimestamp?.toMillis ? updatedAtTimestamp.toMillis() : (data.updatedAt || undefined),
        description: data.description || `A post about ${data.title}`,
      } as BlogPost;
    });
    onUpdate(posts);
  }, (err: any) => {
    console.error(`Error streaming posts for blog ${blogId}:`, err);
    let errorMessage = err.message || 'Unknown error streaming blog posts.';
    if (err.code === 'permission-denied') errorMessage = `Permission denied for posts. Check Firestore rules.`;
    else if (err.code === 'unimplemented' && err.message.includes('currently building')) errorMessage = `Firestore index for posts is building.`;
    else if (err.code === 'failed-precondition' && err.message.includes('query requires an index')) errorMessage = `Firestore query for posts needs an index.`;
    onError(new Error(errorMessage));
  });
}

if (typeof global !== 'undefined') {
  (global as any).formatPostToMarkdown = (post: BlogPost): string => {
    const frontmatterDate = post.createdAt ? new Date(post.createdAt).toISOString().split('T')[0] : new Date().toISOString().split('T')[0];
    const draftStatus = post.status === 'draft' ? true : false;
    const description = post.description || `A summary of ${post.title.replace(/"/g, '\\"')}`;

    return `---
title: "${post.title.replace(/"/g, '\\"')}"
date: ${frontmatterDate}
draft: ${draftStatus}
description: "${description.replace(/"/g, '\\"')}"
---

${post.contentMarkdown || post.content || ''}
`;
  };
}
