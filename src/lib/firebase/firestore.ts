import {
  collection,
  addDoc,
  query,
  where,
  getDocs,
  orderBy,
  Timestamp,
  doc,
  updateDoc,
  deleteDoc,
  onSnapshot,
  type Unsubscribe,
  getDoc,
  setDoc,
} from 'firebase/firestore';
import { db } from './client-config';
import type { Blog, BlogStatus, SelectedTheme, ApiConnection, BlogPost } from '../types';
import { Octokit } from '@octokit/rest'; // Import Octokit

const BLOGS_COLLECTION = 'blogs';
const API_CONNECTIONS_COLLECTION = 'api_connections';
const POSTS_SUBCOLLECTION = 'posts'; // For fetching posts

// Helper function for delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));


async function getBlogPostsForBlog(blogId: string): Promise<BlogPost[]> {
  if (!db) {
    throw new Error("Firestore database is not initialized for fetching posts.");
  }
  const posts: BlogPost[] = [];
  try {
    const postsQuery = query(
      collection(db, BLOGS_COLLECTION, blogId, POSTS_SUBCOLLECTION),
      orderBy('createdAt', 'desc') // Or however you order them
    );
    const querySnapshot = await getDocs(postsQuery);
    querySnapshot.forEach(docSnapshot => {
      const data = docSnapshot.data();
      const createdAtTimestamp = data.createdAt as Timestamp;
      posts.push({
        id: docSnapshot.id,
        ...data,
        createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
        // Ensure all fields from BlogPost are present
      } as BlogPost);
    });
    return posts;
  } catch (error) {
    console.error(`Error fetching posts for blog ${blogId}:`, error);
    throw new Error('Failed to fetch blog posts.');
  }
}

// Helper to format a blog post as Markdown (simplified example)
function formatPostToMarkdown(post: BlogPost): string {
  let content = `---
title: "${post.title}"
date: ${new Date(post.createdAt).toISOString()}
draft: ${post.status === 'draft' ? 'true' : 'false'}
`;
  // Add other frontmatter fields from your BlogPost type as needed
  // e.g., if (post.tags) content += `tags: [${post.tags.map(t => `"${t}"`).join(', ')}]\n`;
  content += `---\n\n${post.contentMarkdown || post.content || ''}`;
  return content;
}


export async function simulateBlogCreationProcess(blogId: string, siteName: string): Promise<void> {
  if (!db) {
    const firestoreErrorMsg = "Firestore not initialized during creation simulation.";
    console.error(firestoreErrorMsg);
    try {
      await updateBlogStatus(blogId, 'failed', { error: firestoreErrorMsg });
    } catch (statusUpdateError) {
      console.error("Failed to update blog status to failed after Firestore initialization check:", statusUpdateError);
    }
    return;
  }

  let blogData: Blog | undefined;
  let octokit: Octokit | undefined;
  let owner = ''; // Will be fetched from GitHub API user endpoint
  const repo = siteName; // GitHub repo name

  try {
    const blogDocRef = doc(db, BLOGS_COLLECTION, blogId);
    const blogDocSnapshot = await getDoc(blogDocRef);

    if (!blogDocSnapshot.exists()) {
      throw new Error(`Blog with ID ${blogId} not found.`);
    }

    const rawData = blogDocSnapshot.data();
    const userId = rawData?.userId;
    if (!userId) { throw new Error('User ID not found in blog document.'); }

    const createdAtTimestamp = rawData.createdAt as Timestamp;
    blogData = {
      id: blogDocSnapshot.id,
      ...rawData,
      createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (rawData.createdAt || 0),
    } as Blog;


    await updateBlogStatus(blogId, 'creating_repo');
    console.log(`Blog ${blogId}: Status updated to creating_repo.`);

    const apiConnections = await getApiConnection(userId);
    const githubApiKey = apiConnections?.githubApiKey;

    if (!githubApiKey) { throw new Error('GitHub API key is missing. Please add your GitHub Personal Access Token in the API Connections settings.'); }

    octokit = new Octokit({ auth: githubApiKey });

    // Get authenticated user's login (owner)
    try {
        const { data: { login } } = await octokit.users.getAuthenticated();
        owner = login;
    } catch (e: any) {
        console.error("Error fetching authenticated GitHub user:", e);
        throw new Error(`Failed to fetch GitHub user login: ${e.message}. Check your PAT permissions.`);
    }


    const sanitizedDescription = (blogData.description || `A Hugo blog for ${siteName} generated by HugoHost`)
      .replace(/[\u0000-\u001F\u007F-\u009F]/g, ' ')
      .replace(/\s\s+/g, ' ')
      .trim();

    console.log(`Blog ${blogId}: Attempting to create GitHub repo "${owner}/${repo}" with description "${sanitizedDescription}".`);
    const repoCreateResponse = await octokit.repos.createForAuthenticatedUser({
        name: repo,
        description: sanitizedDescription,
        private: false, // or true, depending on your needs
        auto_init: false, // Set to false, we will push initial commit
    });


    const githubRepoUrl = repoCreateResponse.data.html_url;
    console.log(`Blog ${blogId}: GitHub repo created successfully: ${githubRepoUrl}`);

    const initialDeploymentNote = "GitHub repository created. Preparing to push initial content.";
    await updateBlogStatus(blogId, 'configuring_theme', { githubRepoUrl, deploymentNote: initialDeploymentNote }); // Temp status

    // --- START: PUSH CONTENT TO GITHUB ---
    await updateBlogStatus(blogId, 'pushing_content_to_repo', { githubRepoUrl, deploymentNote: "Fetching blog posts from Firestore and preparing to push to GitHub..." });
    console.log(`Blog ${blogId}: Fetching blog posts...`);

    const postsToPush = await getBlogPostsForBlog(blogId);
    if (postsToPush.length === 0) {
        console.log(`Blog ${blogId}: No posts found to push. Repository will remain empty for now.`);
        // Potentially push a default README.md or Hugo site structure
    }

    const filesToCommit: { path: string; content: string; mode?: '100644' | '100755' | '040000' | '160000' | '120000', type?: 'blob' | 'tree' | 'commit' }[] = [];

    // Basic Hugo structure (you'll need more for a real Hugo site)
    filesToCommit.push({
      path: 'config.toml', // Or .yaml, .json
      content: `baseURL = "https://${owner}.github.io/${repo}/" # Or your Cloudflare Pages URL
languageCode = "en-us"
title = "${blogData.name || siteName}"
theme = "${blogData.selectedTheme?.name || 'ananke'}" # Example, adjust based on your Blog type
`
    });
    filesToCommit.push({ path: 'content/_index.md', content: `# Welcome to ${blogData.name || siteName}\n\nThis is your new Hugo blog.`});
    filesToCommit.push({ path: 'archetypes/default.md', content: `---
title: "{{ replace .Name "-" " " | title }}"
date: {{ .Date }}
draft: true
---
`});
    // Add .gitattributes or other essential files if needed
    // filesToCommit.push({ path: '.gitattributes', content: `* text=auto eol=lf\n*.png binary\n*.jpg binary`});


    for (const post of postsToPush) {
        // Simple slugification, improve as needed
        const slug = (post.title || `post-${post.id}`).toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
        const filePath = `content/posts/${slug}.md`; // Common Hugo structure
        filesToCommit.push({
            path: filePath,
            content: formatPostToMarkdown(post),
        });
    }

    if (filesToCommit.length > 0) {
        console.log(`Blog ${blogId}: Preparing to commit ${filesToCommit.length} files to ${owner}/${repo}.`);

        // 1. Get the default branch (or create if repo is brand new and auto_init was false)
        // For a newly created repo with auto_init: false, there's no branch yet.
        // We will create the first commit directly on a new branch (e.g. 'main')
        const defaultBranchName = repoCreateResponse.data.default_branch || 'main'; // GitHub is moving to 'main'

        // Create blobs
        const blobCreationPromises = filesToCommit.map(file =>
            octokit.git.createBlob({
                owner,
                repo,
                content: file.content,
                encoding: 'utf-8',
            }).then(response => ({
                path: file.path,
                sha: response.data.sha,
                mode: file.mode || '100644', // 100644 for file, 100755 for executable, 040000 for submodule
                type: file.type || 'blob',     // blob, tree, commit
            }))
        );
        const blobs = await Promise.all(blobCreationPromises);

        // Create a tree
        const { data: tree } = await octokit.git.createTree({
            owner,
            repo,
            tree: blobs.map(b => ({ path: b.path, mode: b.mode, type: b.type, sha: b.sha })),
            // base_tree: parentCommitSha, // Omit for the very first commit
        });

        // Create a commit
        const { data: newCommit } = await octokit.git.createCommit({
            owner,
            repo,
            message: 'Initial commit: Add Hugo structure and blog posts',
            tree: tree.sha,
            // parents: [parentCommitSha], // Omit for the very first commit
        });

        // Update the reference (create the branch for the first commit)
        await octokit.git.createRef({
            owner,
            repo,
            ref: `refs/heads/${defaultBranchName}`,
            sha: newCommit.sha,
        });

        console.log(`Blog ${blogId}: Content successfully pushed to ${defaultBranchName} branch. Commit SHA: ${newCommit.sha}`);
        await updateBlogStatus(blogId, 'generating_config', { // Using existing status, adjust if needed
            githubRepoUrl,
            deploymentNote: `Initial content (${filesToCommit.length} files) pushed to GitHub. The repository now contains a basic Hugo structure and your posts. Ready for Cloudflare Pages to build.`
        });
    } else {
        // If no files to commit, we still need an initial commit for Cloudflare Pages to work.
        // Push a README.md
        const { data: readmeBlob } = await octokit.git.createBlob({
            owner,
            repo,
            content: `# ${blogData.name || siteName}\n\nThis repository was created by HugoHost. Content will be added soon.`,
            encoding: 'utf-8'
        });
        const { data: readmeTree } = await octokit.git.createTree({
            owner,
            repo,
            tree: [{ path: 'README.md', mode: '100644', type: 'blob', sha: readmeBlob.sha }]
        });
        const { data: initialCommit } = await octokit.git.createCommit({
            owner,
            repo,
            message: 'Initial commit: Add README.md',
            tree: readmeTree.sha
        });
        const defaultBranchName = repoCreateResponse.data.default_branch || 'main';
        await octokit.git.createRef({
            owner,
            repo,
            ref: `refs/heads/${defaultBranchName}`,
            sha: initialCommit.sha
        });
        console.log(`Blog ${blogId}: Pushed an initial README.md as no blog posts were found.`);
        await updateBlogStatus(blogId, 'generating_config', {
            githubRepoUrl,
            deploymentNote: "Pushed an initial README.md to GitHub. Add posts in Firestore and re-run or trigger a build for content to appear."
        });
    }

    // --- END: PUSH CONTENT TO GITHUB ---

    await delay(1500); // Simulate further processing if any

    await updateBlogStatus(blogId, 'deploying', { githubRepoUrl, deploymentNote: "Content pushed to GitHub. If Cloudflare Pages is connected to this repository, it should start building and deploying the site." });
    console.log(`Blog ${blogId}: Status updated to deploying. Simulating push of site files to GitHub & triggering deployment...`);
    await delay(4000);

    const simulatedLiveUrl = `https://${repo.toLowerCase() /* or owner.toLowerCase() + '.github.io' if using GH pages directly, or CF pages URL */}.example-pages.dev`; // Placeholder
    const finalDeploymentNote = `Simulation complete. GitHub repository is at ${githubRepoUrl} and now contains initial content. The live URL ${simulatedLiveUrl} is a placeholder. Configure Cloudflare Pages to point to this repository to go live.`;
    await updateBlogStatus(blogId, 'live', {
      githubRepoUrl,
      liveUrl: simulatedLiveUrl,
      deploymentNote: finalDeploymentNote
    });
    console.log(`Blog ${blogId}: Status updated to live. Simulated Live URL: ${simulatedLiveUrl}`);

  } catch (error: any) {
    console.error(`Error in blog creation simulation for ${blogId}:`, error);
    let simulationErrorMessage = `Simulation process failed: ${error.message || 'Unknown error'}`;

    if (error.name === 'HttpError' && error.status) { // Octokit specific error
        simulationErrorMessage = `GitHub API Error (${error.status}): ${error.message}`;
        if (error.response?.data?.message) {
            simulationErrorMessage += ` - ${error.response.data.message}`;
        }
        if (error.response?.data?.errors) {
            simulationErrorMessage += ` Details: ${JSON.stringify(error.response.data.errors)}`;
        }
        console.error("GitHub API Error details:", error.response?.data || error);
    } else if (error.isAxiosError) { // If octokit uses axios internally and an error bubbles up
        simulationErrorMessage = `Network error during GitHub operation: ${error.message}`;
    }


    if (simulationErrorMessage.length > 1000) {
      simulationErrorMessage = simulationErrorMessage.substring(0, 997) + "...";
    }
    try {
      await updateBlogStatus(blogId, 'failed', { error: simulationErrorMessage, githubRepoUrl: (octokit && owner && repo) ? `https://github.com/${owner}/${repo}` : undefined });
      console.log(`Blog ${blogId}: Status updated to failed due to simulation process error.`);
    } catch (statusUpdateError) {
      console.error(`Blog ${blogId}: Failed to update blog status to failed after simulation error:`, statusUpdateError);
    }
  }
}

// Make sure you also have deleteBlog, addBlog, getUserBlogs, streamUserBlogs, getBlog, updateBlogStatus
// ... (other functions from your original code)
// Add a new blog
export async function addBlog(userId: string, blogData: Omit<Blog, 'id' | 'userId' | 'createdAt' | 'status'>): Promise<string> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    const docRef = await addDoc(collection(db, BLOGS_COLLECTION), {
      ...blogData,
      userId,
      status: 'pending' as BlogStatus,
      createdAt: Timestamp.now(), 
    });
    return docRef.id;
  } catch (error) {
    console.error('Error adding blog:', error);
    throw new Error('Failed to add blog to Firestore.');
  }
}

// Get all blogs for a user
export async function getUserBlogs(userId: string): Promise<Blog[]> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    const q = query(
      collection(db, BLOGS_COLLECTION),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc')
    );
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(docSnapshot => {
      const data = docSnapshot.data();
      const createdAtTimestamp = data.createdAt as Timestamp;
      return {
        id: docSnapshot.id,
        ...data,
        createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
      } as Blog;
    });
  } catch (error) {
    console.error('Error fetching user blogs:', error);
    throw new Error('Failed to fetch user blogs.');
  }
}

// Stream user blogs
export function streamUserBlogs(
  userId: string,
  onUpdate: (blogs: Blog[]) => void,
  onError: (error: Error) => void
): Unsubscribe {
  if (!db) {
    const initError = new Error("Firestore database is not initialized. Cannot stream blogs.");
    console.error(initError.message); 
    onError(initError);
    return () => {}; 
  }
  const q = query(
    collection(db, BLOGS_COLLECTION),
    where('userId', '==', userId),
    orderBy('createdAt', 'desc') 
  );

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const blogs = querySnapshot.docs.map(docSnapshot => {
      const data = docSnapshot.data();
      const createdAtTimestamp = data.createdAt as Timestamp;
      return {
        id: docSnapshot.id,
        ...data,
        createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
      } as Blog;
    });
    onUpdate(blogs);
  }, (err: any) => { 
    console.error("Error streaming user blogs from Firestore:", err);
    let errorMessage = err.message || 'An unknown error occurred while streaming blogs.';
    if (err.code === 'failed-precondition' && err.message.includes('query requires an index')) {
        errorMessage = `Firestore query requires an index. Please create it in the Firebase console. Details: ${err.message}`;
    } else if (err.code === 'permission-denied') {
        errorMessage = `Permission denied when trying to stream blogs. Check Firestore security rules. Details: ${err.message}`;
    } else if (err.code === 'unimplemented' && err.message.includes('currently building')) {
      errorMessage = `The required Firestore index is currently building and cannot be used yet. Please try again in a few minutes. Original error: ${err.message}`;
    }
    onError(new Error(errorMessage));
  });

  return unsubscribe;
}

// Get a single blog by ID, ensuring it belongs to the user
export async function getBlog(blogId: string, userId: string): Promise<Blog | null> {
  if (!db) {
    throw new Error("Firestore database is not initialized.");
  }
  if (!blogId || !userId) {
    // This check is primarily for developers, UI should prevent this.
    console.error("getBlog called with missing blogId or userId.");
    throw new Error("Blog ID and User ID are required to fetch a blog.");
  }
  try {
    const blogRef = doc(db, BLOGS_COLLECTION, blogId);
    const docSnapshot = await getDoc(blogRef);

    if (docSnapshot.exists()) {
      const data = docSnapshot.data();
      if (data.userId !== userId) {
        console.warn(`User ${userId} attempted to access blog ${blogId} owned by ${data.userId}. This should be caught by security rules.`);
        // Depending on security model, either return null or throw specific permission error.
        // For client-side, null is often safer to prevent information leakage.
        return null; 
      }
      const createdAtTimestamp = data.createdAt as Timestamp;
      return {
        id: docSnapshot.id,
        ...data,
        createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
      } as Blog;
    }
    return null; // Blog not found
  } catch (error: any) {
    console.error(`Error fetching blog ${blogId}:`, error);
    // Don't expose too much detail to the client. Log it for server-side debugging.
    throw new Error(`Failed to fetch blog details. Please try again.`);
  }
}


// Update blog status
export async function updateBlogStatus(blogId: string, status: BlogStatus, details?: Partial<Pick<Blog, 'githubRepoUrl' | 'liveUrl' | 'error' | 'deploymentNote'>>): Promise<void> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    const blogRef = doc(db, BLOGS_COLLECTION, blogId);
    await updateDoc(blogRef, { status, ...details, updatedAt: Timestamp.now() });
  } catch (error) {
    console.error('Error updating blog status:', error);
    throw new Error('Failed to update blog status.');
  }
}

// Delete a blog
export async function deleteBlog(blogId: string): Promise<void> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    const blogRef = doc(db, BLOGS_COLLECTION, blogId);
    await deleteDoc(blogRef);
    // Note: This does not delete subcollections like 'posts'. 
    // If you need to delete posts, you'd need a separate (likely Cloud Function) process.
  } catch (error) {
    console.error('Error deleting blog:', error);
    throw new Error('Failed to delete blog.');
  }
}



// Save API connections for a user
export async function saveApiConnection(userId: string, data: Partial<Omit<ApiConnection, 'userId'>>): Promise<void> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized. Cannot save API connections.");
    }
    if (!userId) {
      throw new Error("User ID is missing. Unable to save API connections.");
    }
    const apiConnectionRef = doc(db, API_CONNECTIONS_COLLECTION, userId);
    
    const dataToSave: Partial<ApiConnection> = { userId };
    (Object.keys(data) as Array<keyof Omit<ApiConnection, 'userId'>>).forEach(key => {
      if (data[key] !== undefined) {
        (dataToSave as any)[key] = data[key];
      }
    });

    await setDoc(apiConnectionRef, dataToSave, { merge: true });
  } catch (error: any) {
    console.error('Detailed error saving API connection to Firestore:', error); 
    let toastMessage = "Failed to save API connections.";
    if (error.code === 'permission-denied') {
        toastMessage += " Please check Firestore security rules to ensure you have write access.";
    } else if (error.message) {
        const detailSnippet = error.message.length > 100 ? error.message.substring(0,97) + "..." : error.message;
        toastMessage += ` Details: ${detailSnippet}`;
    } else {
        toastMessage += " An unexpected issue occurred. More details logged on the server.";
    }
     if (toastMessage.length > 250) {
        toastMessage = toastMessage.substring(0, 247) + "...";
    }
    throw new Error(toastMessage); 
  }
}

// Get API connections for a user
export async function getApiConnection(userId: string): Promise<ApiConnection | null> {
  try {
    if (!db) {
      throw new Error("Firestore database is not initialized.");
    }
    if (!userId) {
      throw new Error("User ID is required to get API connections.");
    }
    const apiConnectionRef = doc(db, API_CONNECTIONS_COLLECTION, userId);
    const docSnapshot = await getDoc(apiConnectionRef);

    if (docSnapshot.exists()) {
      const data = docSnapshot.data();
      return {
        userId: data.userId, 
        githubApiKey: data.githubApiKey || undefined,
        cloudflareApiToken: data.cloudflareApiToken || undefined,
        cloudflareApiKey: data.cloudflareApiKey || undefined,
        cloudflareEmail: data.cloudflareEmail || undefined,
        cloudflareAccountId: data.cloudflareAccountId || undefined,
      } as ApiConnection;
    }
    return null;
  } catch (error) {
    console.error('Error fetching API connection:', error);
    throw new Error('Failed to fetch API connection from Firestore.');
  }
}

// Add a new blog post to a specific blog
export async function addBlogPost(
  userId: string,
  blogId: string,
  postData: Omit<BlogPost, 'id' | 'blogId' | 'userId' | 'createdAt' | 'updatedAt'>
): Promise<string> {
  if (!db) {
    throw new Error("Firestore database is not initialized.");
  }
  if (!userId || !blogId) {
    throw new Error("User ID and Blog ID are required to add a blog post.");
  }
  try {
    const blog = await getBlog(blogId, userId);
    if (!blog) {
      throw new Error("Blog not found or user does not have permission.");
    }

    const postsCollectionRef = collection(db, BLOGS_COLLECTION, blogId, POSTS_SUBCOLLECTION);
    const docRef = await addDoc(postsCollectionRef, {
      ...postData,
      userId, 
      blogId, 
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    });
    return docRef.id;
  } catch (error) {
    console.error('Error adding blog post:', error);
    throw new Error('Failed to add blog post to Firestore.');
  }
}

// Stream blog posts for a specific blog, ensuring user owns the blog
export function streamBlogPosts(
  userId: string,
  blogId: string,
  onUpdate: (posts: BlogPost[]) => void,
  onError: (error: Error) => void
): Unsubscribe {
  if (!db) {
    const initError = new Error("Firestore database is not initialized. Cannot stream blog posts.");
    console.error(initError.message);
    onError(initError);
    return () => {};
  }
  if (!userId || !blogId) {
    const paramsError = new Error("User ID and Blog ID are required to stream posts.");
    console.error(paramsError.message);
    onError(paramsError);
    return () => {};
  }

  const postsCollectionRef = collection(db, BLOGS_COLLECTION, blogId, POSTS_SUBCOLLECTION);
  // Adding a where clause for userId on the subcollection query, if your rules allow/require it.
  // This assumes posts in the subcollection also have a userId field.
  const q = query(postsCollectionRef, where("userId", "==", userId), orderBy('createdAt', 'desc'));
  // If posts don't have userId or rules are based on parent doc ownership, remove where("userId", "==", userId)

  const mainUnsubscribe = onSnapshot(q, (querySnapshot) => {
    const posts = querySnapshot.docs
      .map(docSnapshot => {
        const data = docSnapshot.data();
        const createdAtTimestamp = data.createdAt as Timestamp;
        const updatedAtTimestamp = data.updatedAt as Timestamp;
        return {
          id: docSnapshot.id,
          blogId: blogId, 
          userId: data.userId, 
          ...data,
          createdAt: createdAtTimestamp?.toMillis ? createdAtTimestamp.toMillis() : (data.createdAt || 0),
          updatedAt: updatedAtTimestamp?.toMillis ? updatedAtTimestamp.toMillis() : (data.updatedAt || undefined),
        } as BlogPost;
      });
    onUpdate(posts);
  }, (err: any) => {
    console.error(`Error streaming posts for blog ${blogId} (user ${userId}):`, err);
    let errorMessage = err.message || 'An unknown error occurred while streaming blog posts.';
     if (err.code === 'permission-denied') {
        errorMessage = `Permission denied. Check Firestore rules for posts subcollection. Details: ${err.message}`;
    } else if (err.code === 'unimplemented' && err.message.includes('currently building')) {
        errorMessage = `Firestore index for posts is building. Try again soon. Details: ${err.message}`;
    } else if (err.code === 'failed-precondition' && err.message.includes('query requires an index')) {
        // This error might occur if the where("userId", "==", userId) clause is added and needs an index.
        errorMessage = `Firestore query for posts requires an index (likely on userId and createdAt). Please create it. Details: ${err.message}`;
    }
    onError(new Error(errorMessage));
  });

  return mainUnsubscribe;
}
